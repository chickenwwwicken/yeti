#### Function
``` python
def area_of_circle (r):
	pi = 3.14
	result = pi * r * r
	return result

area = area_of_circle(5)
print(area)
```

- ```def``` : standard for defining a function
- ```area_of_circle``` : name of the function (arbitrary)
- ```pi``` :  variable (arbitrary)
- ```result``` : variable (arbitrary)
- ```return``` : keyword that tells function what to give as output (can be more than 1)
- ```r``` : parameter - the name of an input (arbitrary)
- ```5``` : the argument , replaces the parameter of the function

#### Multiple Parameters
FUNCTION
``` python
def create_introduction(name, age, height, weight):
    first_part = "Your name is " + name + " and you are " + age + " years old."
    second_part = "You are " + height + " meters tall and weigh " + weight + " kilograms."
    full_intro = first_part + " " + second_part
    return full_intro
```

Can be called like this
``` python
my_name = "John"
my_age = "30"

intro = create_introduction(my_name, my_age, "1.8", "80")
print(intro)
# Your name is John and you are 30 years old. You are 1.8 meters tall and weigh 80 kilograms.
```

#### Multiple Returns
``` python
def cast_iceblast(wizard_level, start_mana):
    damage = wizard_level * 2
    new_mana = start_mana - 10
    return damage, new_mana # Return two values


dmg, mana = cast_iceblast(5, 100)
print(f"Damage: {dmg}, Remaining Mana: {mana}")
# Damage: 10, Remaining Mana: 90
```

---
## 3.7 Returning multiple values

``` python
def cast_iceblast(wizard_level, start_mana):
    damage = wizard_level * 2
    new_mana = start_mana - 10
    return damage, new_mana # Return two values


dmg, mana = cast_iceblast(5, 100)
print(f"Damage: {dmg}, Remaining Mana: {mana}")
# Damage: 10, Remaining Mana: 90
```

When ```cast_iceblast``` is called, it returns two values = ```damage``` , ```new_mana```
These only exist inside the function.... 

```cast_iceblast(5, 100)``` = ```10, 90``` 
so...
```dmg, mana``` = ```10, 90```

Now you can print ```dmg``` ```mana``` 

---
## 3.9 Adding default values
A default value is created by using the assignment ```=``` operator in the function signature.

``` python
def get_greeting(email,name="there"):
	print("Hello", name, "welcome! ur email is:", email)
```

---
[[3.0_Funciones]]

---
## 5.1 add xp and level to give new xp

``` python
def total_xp(level, xp_to_add):
    old_xp = level * 100
    new_xp = xp_to_add + old_xp
    return new_xp
```

Complete the ```total_xp``` function. It accepts two integers as input:
- ```level```
- ```xp_to_add```

There are 100 xp per level. ```total_xp``` should convert the current `level` to xp, then add this current xp to the `xp_to_add` argument and return the player's total xp. For example:

- If a player is level 1 and gains 100 xp, they have 200 total xp.
- If a player is level 2 and gains 250 xp, they have 450 total xp.
- If a player is level 170 and gains 590 xp, they have 17590 total xp.

---
##  5.3 Applying Damage to player health 

``` python
def take_magic_damage(health, resist, amp, spell_power):
    max_damage = spell_power * amp
    total_damage = max_damage - resist
    new_health = health - total_damage
    return new_health
```

Complete the `take_magic_damage` function. 
Should return the new health after calculating the magic-type damage the player takes. 
Here is a description of the arguments:

- `health`: The player's starting health
- `resist`: The player's magic resistance. This reduces the damage they take by a static amount
- `amp`: The attacker's magic amplification. This increases the damage they deal by a multiplier
- `spell_power`: The base damage of the spell

Calculate the total maximum damage by multiplying the `spell_power` by the `amp`. 
Then, subtract the resist from the total damage to get the actual damage dealt. 
Apply that damage to the player's health and return the new health.

---
## 5.x Unlocking Achievement (with return message)

``` python
def unlock_achievement(before_xp, ach_xp, ach_name):
    new_xp = before_xp + ach_xp
    ach_message = f'Achievement Unlocked: {ach_name}'
    return new_xp , ach_message
```

Let's complete the `unlock_achievement` function. It accepts 3 arguments:
-  `before_xp`: int
- `ach_xp`: int
- `ach_name`: str

It should return 2 values:
- The player's xp after the achievement is unlocked (The sum of `before_xp` and `ach_xp`)
- An alert message that says `"Achievement Unlocked: ACHIEVEMENT_NAME"`, where `ACHIEVEMENT_NAME` is the name of the achievement 
---
[[5.0_Testing]]

---
## 6.1 Calculate total + average ddamage

``` python
def calculate_damage(sword, arrow, spear, dagger, fireball):
    total_damage = sword + arrow + spear + dagger + fireball
    average_damage = total_damage / 5
    return total_damage, average_damage
```

Complete the missing sections of the `calculate_damage` function.

- Fix the `total_damage` variable so that it contains the sum of all the different weapons' damage values.
- Fix the `average_damage` variable so that it contains the average weapon damage.

---
## 6.2 Floor removedd (division to keep integers)

``` python
7 // 2
# 2 (an integer)
```

---
## 6.3 Exponents

``` python
# reads as "three squared" or
# "three raised to the second power"
3 ** 2
# 9
```

---
## 6.4 Changing value of same variable

``` python
def update_player_score(current_score, increment):
    current_score = current_score + increment
    return current_score
```

Change `current_score`  to be `current_score` + `increment`


---
## 6.5 Operators + Variables

``` python
star_rating = 4
star_rating += 1
# star_rating is now 5

star_rating = 4
star_rating -= 1
# star_rating is now 3

star_rating = 4
star_rating *= 2
# star_rating is now 8

star_rating = 4
star_rating /= 2
# star_rating is now 2.0
```

``` python
def get_hurt(current_health, damage):
    current_health -= damage
    return current_health
```

Complete `get_hurt` function.
should use `-=` in-place operator to subtract `ddamage` from `current_health` 
then return the new `current_health`

Can not use these in return statements!!!

---
## 6.6 Scientific notation

``` python
def max_players_on_server():
    small_server = 1.024e18
    medium_server = 1.024e19
    large_server = 1.024e20
    return small_server, medium_server, large_server
```

Complete the `max_players_on_server` function.
It takes no inputs, simply returns 3 static values:
1.  max players on 'small' server: `1,024,000,000,000,000,000` (`1.024e18`)
2.  max players on a 'medium' server: `10,240,000,000,000,000,000` 
3. max players on a 'large' server: `102,400,000,000,000,000,000` 
Use scientific notationto represent numbers.

---
## 6.8  Binary Numbers Syntax

``` python
print(0b0001)
# prints 1
print(0b1101)
# prints 13
```

---
## Bitwise & Operator

``` python
0101
&
0111 # just 3 column is not True with '&' operator
=
0101
```

---
## Guild Permissions with Bitwise "and"

``` python
can_create_guild = 0b1000
can_review_guild = 0b0100
can_delete_guild = 0b0010
can_edit_guild = 0b0001

# inputs for user_permissions
# - 1111
# - 1100
# - 0110
# - 0000 

def get_create_bits(user_permissions):
    return can_create_guild & user_permissions


def get_review_bits(user_permissions):
    return can_review_guild & user_permissions


def get_delete_bits(user_permissions):
    return can_delete_guild & user_permissions


def get_edit_bits(user_permissions):
    return can_edit_guild & user_permissions
```

---
## 6.10 Guild Permissions with Bitwise "or"

``` python
def calculate_guild_perms(glorfindel, galadriel, elendil, elrond):
    guild_perms = glorfindel | galadriel | elendil | elrond
    return guild_perms

# inputs
#  glor     gala     ele    elro  expected
# (0b0001, 0b0010, 0b0001, 0b1011, 0b1011)
# (0b0000, 0b0000, 0b0000, 0b1011, 0b1011)
# (0b1001, 0b0010, 0b1101, 0b1011, 0b1111)
```

Complete the `calculate_guild_perms` function. It should return a binary number that represents the permissions of all the members of the guild (Glorfindel, Galadriel, Elendil and Elrond).

---
## 6.11 Not
Reverses the result
``` python
print(not True)
# Prints: False

print(not False)
# Prints: True
```

---
## 6.12 Converting Strings to Integers (Binary)

``` python
def binary_string_to_int(num_servers, num_players, num_admins):
    int_servers = int(num_servers, 2)
    int_players = int(num_players, 2)
    int_admins = int(num_admins, 2)
    return int_servers, int_players, int_admins

# inputs
# ("1", "10", "1010", (1, 2, 10))
# ("101", "11", "10100", (5, 3, 20)),
# ("111", "1011", "11010", (7, 11, 26)),
```

---
## 7.1 Compare Scores in Boolean

``` python
def player_1_wins(player_1_score, player_2_score):
    return player_1_score > player_2_score
```

Complete the `player_1_wins` function.
It should return `True` if player 1 has a higher score, and `False` otherwise.

``` python
def compare_heights(edward_height, alphonse_height, winry_height, mustang_height):
    is_mustang_edward_same = edward_height == mustang_height
    is_alphonse_edward_same = alphonse_height == edward_height
    is_winry_alphonse_same = alphonse_height == winry_height
    return is_mustang_edward_same, is_alphonse_edward_same, is_winry_alphonse_same

# inputs
#     (5, 5, 7, 5, (True, True, False)),
#     (6, 6, 5, 5, (False, True, False)),
#     (4, 4, 4, 4, (True, True, True)),
#     (2, 2, 2, 2, (True, True, True)),
#     (5, 7, 9, 11, (False, False, False)),
#     (11, 9, 7, 5, (False, False, False)),

compare_heights
```

Use comparison operators to determine their boolean values.
The context of the parameter names should tell you how to make these comparisons.
Return them in this order:

1. `is_mustang_edward_same`
2. `is_alphonse_edward_same`
3. `is_winry_alphonse_same`



---
##  7.2 If ==

``` python
def check_swords_for_army(number_of_swords, number_of_soldiers):
	# check if equal
    if number_of_swords == number_of_soldiers:
        return 'correct amount'
    # if not equal 
    return 'incorrect amount'
```

---
## 7.3 If-Else example

``` python
def player_status(health):
    if health <= 0 :
        return 'dead'
    elif health <= 5 :
        return 'injured'
    return 'healthy'
```

``` python
def check_high_score(current_player_name, high_scoring_player_name):
    if current_player_name == high_scoring_player_name:
        return "You are the highest scoring player!"
    else:
        return "You are not the highest scoring player!"
```

---
## tracking hit or miss

``` python
def does_attack_hit(attack_roll, armor_class):
    if (attack_roll != 1 and attack_roll >= armor_class) or attack_roll == 20:
        return True
    return False
```

function for tracking whether a character's attack hits or misses

Function should return `True` if either of the following conditions are met:
- The `attack_roll` is not a `1` and attack roll is `>=` `armor_class`, or
- The attack roll is a `20` 

Otherwise return `False` 

---
## 7.5 Serving Alcohol?

``` python
def should_serve_customer(customer_age, on_break, time):
    if (
        customer_age >= 21
        and on_break == False
        and time >= 5 and time <= 10
    ):
        return True
    return False

# or

def should_serve_customer(customer_age, on_break, time):
	if customer_age < 21:
		return False
	if on_break:
		return False
	if time < 5 or time > 10:
		return False
	return True
```

Complete the function that determines if a bartender should serve drinks to customer.
Only return `True` if all of these conditions apply, else return `False`:
- The customer's age is 21 or older
- The bartender is working
- The time is at least 5 but no later than 10

---
## 7.5 Calculate energy needed for trip

``` python
def has_enough_energy(energy_available, distance_one_way, meters_per_energy):
    energy_needed = distance_one_way * 2 / meters_per_energy
    return energy_needed <= energy_available:
```

Determine how many energy points you need to go and come back.
Assign the result to a `energy_needed` variable. 
`meters_per_energy` is how far u can travel with one energy point.

Return `True` if there is at least enough energy based on the `energy_needed` variable, 
and `False` otherwise.

---
## 8.1 For Loops for printing numbers

``` python
for i in range(0,10):
	print(i)
```

---
## 8.1 For loop printing inside function

``` python
def print_numbers_from_five_to(end):
	for i in range(5,end):
		print(i)
```

---
## 8.2 Range loops with step

``` python
for i in range(0, 10, 2):
	print(i)
# prints : 0,2,4,6,8
```

``` python
for i in range(3, 0, -1)
	print(i)
# prints : 3, 2, 1
```

``` python
# inside a function for end and start variables
def count_down(start, end):
	for i in range(start, end, -1):
		print(i)
```

---
## sum of numbers in range

``` python
def sum_of_numbers(start, end):
    total = 0
    for i in range(start, end):
        total += i
    return total

```

---
## sum of odd numbers

``` python
def sum_of_odd_numbers(end):
    total = 0
    for i in range(1, end, 2):
        total += i
    return total
```

---
## 8.3 While loop health regeneration

``` python
def regenerate(current_health, max_health, enemy_distance):
    while current_health < max_health and enemy_distance > 3:
        current_health += 1
        enemy_distance -= 2
    return current_health
            
```

In `Fantasy Quest`, player characters regenerate health while standing still far from enemies.

`regenerate` function takes `current_health` `max_health` `enemy_distance` integers.
- while regenerating health, character gains health until it reaches `max_health`
- for every `1` health char gains, the `enemy_distance` shortens by `2`
- If enemy is a distance of `3` or less from char, char stops gaining health.
- Return `current_health` after it stops gaining health.

---
## Print 'Fight!' at 1

``` python
def countdown_to_start():
    for i in range(10 , 0, -1):
        if i > 1:
            print(f'{i}...')
    print(f'{1}...Fight!')

# 10...
# 9...
# 8...
# 7...
# 6...
# 5...
# 4...
# 3...
# 2...
# 1...Fight!
```

---
## Calculating Critical Hits

``` python
def calculate_flurry_crit(num_attacks, base_damage):
    total_damage = 0
    for i in range(0, num_attacks):
        if i == num_attacks -1:
            total_damage += base_damage*4
        else:
            total_damage += base_damage*2
    return total_damage
```

In the `calculate_flurry_crit` function, write a loop that calculates and returns the `total_damage` of the flurry.

The function takes 2 inputs `num_attacks`, `base_damage`.

Range over the `num_attacks` for the flurry
Calculate the total damage for each attack within the flurry. Remember, critical hits do double the `base_damage`!
The final swing of the flurry should do 4x the `base_damage`
Return the total damage

---
## Loop for Leveling up w XP

``` python
def calculate_experience_points(level):
    level_up_xp = 0
    total_xp = 0
    for i in range(level):
        total_xp += level_up_xp
        level_up_xp += 5   
    return total_xp
# or 
def calculate_experience_points(level):
    xp = 0
    for i in range(1, level):
        xp += i * 5
    return xp
```

Each character starts with 0 XP at level 1. 
To reach the next level, they need XP equal to their current level times 5.

![[ss8.3py1.png]]

---
## 8.4 Check if Prime number

``` python
def is_prime(number):	
	if number < 2:
		return False
	for i in range(2, number):
		if number % i == 0:
			return False
	return True
```



---
## Mana Meditating

``` python
def meditate(mana, max_mana, energy, energy_potions):
	# 
    while mana < max_mana and (energy > 0 or energy_potions > 0):
        if energy == 0:
            energy_potions -= 1
            energy += 50
        mana += 3
        energy -= 1
    if mana > max_mana:
        mana = max_mana
    return mana, energy, energy_potions
```

Complete the meditate function using a while loop. It takes `mana`, `max_mana`, `energy` and `energy_potions` integers.

- While meditating, a character converts `1` `energy` into up to `3` `mana` for each iteration of the loop.
- `mana` cannot exceed the `max_mana`.
- If they have any `energy_potions` when they run out of energy, they will use 1 energy potion to gain `50` `energy` and continue meditating.
- A character will stop meditating if either:
	- Their `mana` reaches the `max_mana`, or
	- They run out of `energy` and `energy_potions`.
Return the `mana` and remaining `energy` and `energy_potions` when the character stops meditating.

Tip
Don't forget! A character cannot have more `mana` than their `max_mana` threshold. Be sure to handle cases where meditate raises their `mana` above their max.

---
## 9.1 Lists Formats + Indexing

``` python
flower_types = [
    "daffodil",
    "rose",
    "chrysanthemum"
]

player_ages = [
    23,
    18,
    31,
    42
]

# index 0: 23
# index 1: 18
# index 2: 31
# index 3: 42
```

---
## 9.3 Print an index value

``` python
best_languages = ["JavaScript", "Go", "Rust", "Python", "C"]
print(best_languages[1])
# prints "Go"
```

---
## 9.4 Get Length of a list

``` python
fruits = ["apple", "banana", "pear"]
length = len(fruits)
# 3
```

---
## 9.4 Get last item in a list

``` python
def get_last_index(inventory):
return len(inventory) - 1
```

---
## 9.5 Updating an item in a List

``` python
inventory = ["Leather", "Iron Ore", "Healing Potion"]
inventory[0] = "Leather Armor" 
# inventory: ["Leather Armor", "Iron Ore", "Healing Potion"]
```

Function for it:

``` python
def smelt_ore(inventory):
    if inventory[1] == "Iron Ore":
        inventory[1] = "Iron Bar"
    return inventory
```

When a player tries to smelt `Iron Ore` we need to change it into an `Iron Bar`
But only if they have `Iron Ore` (which will always be at index 1) in their inventory slot.

---
## 9.6 Adding values to a list

``` python
cards = []
cards.append('nvidia')
cards.append('amd')
# cards list is now ['nvidia', 'amd']
```

### Generating Player IDs

``` python
def generate_user_list(num_of_users):
	player_ids = []

	for i in range(0,num_of_users):
		player_ids.append(i)
```

---
## 9.7 Removing the last value of a list w/.pop()

``` python
vegetables = ["broccoli", "cabbage", "kale", "tomato"];
last_vegetable = vegetables.pop()
# vegetables = ['broccoli', 'cabbage', 'kale']
# last_vegetable = 'tomato'
```

### 9.7 Popping and using it as a variable

``` python
def clear_inventory():
    inventory = [
        "Healing Potion",
        "Iron Bar",
        "Kite Shield",
        "Shortsword",
        "Leather Scraps",
        "Tattered Cloth",
    ]
    
    print(f"inventory: {inventory}")

    for i in range(0, len(inventory)):
        item = inventory.pop()

        print(f"Selling: {item}")
        print(f"inventory: {inventory}")


```

---
## 9.8 Print each item in a list

``` python
for i in range(0, len(sports)):
	print(sports[i])
```

### Counting Items in a list

``` python
def get_item_counts(items):
    potion_count = 0
    bread_count = 0
    shortsword_count = 0

	for i in range(0, len(items)):
		if items[i] == "Potion":
			potion_count += 1
		elif items[i] == "Bread":
			bread_count += 1
		elif items[i] == "Shortsword":
			shortsword_count += 1

	return potion_count, bread_count, shortsword_count
```

---
## 9.9 Iterate directly over items 

``` python
trees = ['oak', 'pine', 'maple']
for tree in trees:
	print(tree)

# prints:
# oak
# pine
# maple
```

---
## 9.x Func for finding a specific item in items (boolean)

``` python
def contains_leather_scraps(items):
	found = False
	for item in items:
		if item == 'Leather Scraps':
			found = True
	return found
```

---
## 9.10 Comparing Values in list (printing uplevels)
(works if lists are same size)

``` python
def check_character_levels():
    old_character_levels = [1, 42, 43, 53, 12, 3, 32, 34, 54, 32, 43]
    new_character_levels = [1, 42, 45, 54, 12, 3, 32, 38, 54, 32, 42]

	for i in range(0, len(old_character_levels)):
		if old_character_levels[i] < new_character_levels[i]:
			print(i)
```

We keep track of each character's level in a list. 
When someone levels up, we wanna know bout it so we can congratulate em.
Assignment is to compare `old_character_levels` and `new_character_levels` lists.
Print the index where a character's level increased.

---
## 9.11 Finding maximum value in a list of values

``` python
def find_max(nums):
    max_so_far = float("-inf")
    for i in range(0, len(nums)):
        if nums[i] > max_so_far:
            max_so_far = nums[i]
    return max_so_far
```

Complete the `find_max` function that looks at each number in the `nums` list and returns the maximum value. If no maximum is found, it just returns negative infinity. I've added it for you as the starting value of `max_so_far`.

---
## 9.12 Get odd numbers in a clean list with modulo

``` python
def get_odd_numbers(num):
	odd_numbers = []
	for i in range(0, num):
		if i % != 0:
			odd_numbers.append(i)
	return odd_numbers
```

---
## 9.13 Slicing bitch

``` python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers[:3] # Gives [0, 1, 2]
numbers[3:] # Gives [3, 4, 5, 6, 7, 8, 9]
numbers[::2] # Gives [0, 2, 4, 6, 8]
numbers[-3:] # Gives [7, 8, 9]
numbers[-1] # Gives 9
numbers[::-1] # Gives [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

numbers = []
numbers[2:] # Gives []
numbers[:-2] # Gives []
numbers[::2] # Gives []
```

---
## 9.14 Concatenating lists

``` python
total = [1, 2, 3] + [4, 5, 6]
print(total)
# prints [1, 2, 3, 4, 5, 6]

def concatenate_favorites(favorite_weapons, favorite_armor, favorite_items):
    combined_favorites = favorite_weapons + favorite_armor + favorite_items
    return combined_favorites
```

---
## 9.15 check if word is IN list (Boolean)

``` python
fruits = ["apple", "orange", "banana"]
print("banana" in fruits)
# Prints: True
```

### In a function...

``` python
def is_top_weapon(weapon):
    top_weapons = [
        "sword of justice",
        "sword of slashing",
        "stabby daggy",
        "great axe",
        "silver bow",
        "spellbook",
        "spiked knuckles",
    ]
    
    return weapon in top_weapons
```

Checking if `weapon` variable exists in `top_weapons` list

---
## 9.16 Deleting in Lists

``` python
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# delete the fourth item
del nums[3]
print(nums)
# Output: [1, 2, 3, 5, 6, 7, 8, 9]

# delete the second item up to (but not including) the fourth item
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del nums[1:3]
print(nums)
# Output: [1, 4, 5, 6, 7, 8, 9]

# delete all elements
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del nums[:]
print(nums)
# Output: []
```

### In a Function...

``` python
def trim_strongholds(strongholds):
	del strongholds[0] , strongholds[-2:]
```

1. Delete the first stronghold from the list
2. Delete the last two strongholds from the list

---
## 9.17 Accessing Tuples

``` python
my_tuples = [("1st tuple", 45, True),("2nd tuple", 21, False)]
print(my_tuples[0][0]) # 1st tuple
print(my_tuples[0][1]) # 45
print(my_tuples[1][0]) # 2nd tuple
print(my_tuples[1][2]) # False
```

- First index accesses tuple u want.
- Second index accesses value inside that tuple.

another example of syntax:

``` python
def get_heroes():
    heroes = [
        ("Glorfindel", 2093, True),
        ("Gandalf", 1054, False),
        ("Gimli", 389, False),
        ("Aragorn", 87, False)
    ]
    return heroes
```

---
## 9.x Return first item of list, or ERROR if empty

``` python
def get_first_item(items):
    if len(items) == 0:
        return 'ERROR'
    return items[0]
```

---
## 9.x Reverse List

``` python
def reverse_array(items):
	# Create new list
    items_reversed = []

	# for every item in this list, append the popped item to the new list
    for i in range(0,len(items)):
        items_reversed.append(items.pop())

	# Return new list
    return items_reversed
```

```
---------------------------------
Input array: ['Shortsword', 'Healing Potion', 'Iron Breastplate', 'Kite Shield']
Expected reversed array: ['Kite Shield', 'Iron Breastplate', 'Healing Potion', 'Shortsword']
Actual reversed array: ['Kite Shield', 'Iron Breastplate', 'Healing Potion', 'Shortsword']
Pass
---------------------------------
Input array: [1, 2, 300, 4, 5]
Expected reversed array: [5, 4, 300, 2, 1]
Actual reversed array: [5, 4, 300, 2, 1]
Pass
============= PASS ==============
2 passed, 0 failed
```

---
## 9.18 Filtering messages

``` python
def filter_messages(messages):
	filtered_messages = []
	words_removed = []
	for message in messages:
		# creating a list with .split() method (splits a full message into words)
		words = message.split()
		# new list for filtered words
		new_words = []
		# new variable to count how many words have been removed
		removed = 0
		# check if each word equals to dang
		for word in words:
			if word == "dang":
				# add 1 to our counter if word equals dang
				removed += 1
			else: 
				# adding words not equal to dang to new_words list
				new_words.append(word)
		# re-making words into full messages with .join() and adding em to filtered messages
		filtered_messages.append(" ".join(new_words))
		# making a list of the count of dang in each message.
		words_removed.append(removed)
	return filtered_messages, words_removed
```

```
Input:
 * messages: ['well dang it', 'dang the whole dang thing', 'kill that knight, dang it', 'get him!', 'donkey kong', 'oh come on, get them', 'run away from the dang baddies']
Expecting:
 * filtered messages: ['well it', 'the whole thing', 'kill that knight, it', 'get him!', 'donkey kong', 'oh come on, get them', 'run away from the baddies']
 * words removed: [1, 2, 1, 0, 0, 0, 1]
Actual:
 * filtered messages: ['well it', 'the whole thing', 'kill that knight, it', 'get him!', 'donkey kong', 'oh come on, get them', 'run away from the baddies']
 * words removed: [1, 2, 1, 0, 0, 0, 1]
Pass
============= PASS ==============
2 passed, 0 failed
```

---
## 9.x counting odds & evens in a list of numbers

``` python
def get_odds_and_evens(numbers):
    num_odds = 0
    num_evens = 0
    for number in numbers:
        if number % 2 == 0:
            num_evens += 1
        else: 
            num_odds += 1
    return num_odds, num_evens
```

```
---------------------------------
Inputs: [1, 7, 2, 5, 3, 4]
Expecting: (4, 2)
Actual: (4, 2)
Pass
---------------------------------
Inputs: [0, 99, 2, 33, 61, 44, 9, 10, 12, 240, 35, 9082, 1234]
Expecting: (5, 8)
Actual: (5, 8)
Pass
============= PASS ==============
2 passed, 0 failed
```

---
## 9.x Separate players into odd index and even index

``` python
def split_players_into_teams(players):
    even_team = players[::2]
    odd_team = players[1::2]
    return even_team, odd_team
```

```
---------------------------------
Inputs: ['Harry', 'Hermione', 'Ron', 'Ginny', 'Fred', 'Neville', 'Draco', 'Luna', 'Cho', 'Gregory', 'Lee', 'Michael', 'Lavender', 'Frank', 'Anthony', 'Allan']
Expecting: (['Harry', 'Ron', 'Fred', 'Draco', 'Cho', 'Lee', 'Lavender', 'Anthony'], ['Hermione', 'Ginny', 'Neville', 'Luna', 'Gregory', 'Michael', 'Frank', 'Allan'])
Actual: (['Harry', 'Ron', 'Fred', 'Draco', 'Cho', 'Lee', 'Lavender', 'Anthony'], ['Hermione', 'Ginny', 'Neville', 'Luna', 'Gregory', 'Michael', 'Frank', 'Allan'])
Pass
---------------------------------
Inputs: ['Mike', 'Walter', 'Skyler', 'Tuco']
Expecting: (['Mike', 'Skyler'], ['Walter', 'Tuco'])
Actual: (['Mike', 'Skyler'], ['Walter', 'Tuco'])
Pass
---------------------------------
Inputs: ['Alice', 'Bob', 'Charlie', 'David']
Expecting: (['Alice', 'Charlie'], ['Bob', 'David'])
Actual: (['Alice', 'Charlie'], ['Bob', 'David'])
Pass
---------------------------------
Inputs: []
Expecting: ([], [])
Actual: ([], [])
Pass
============= PASS ==============
4 passed, 0 failed
```

---
## 9.x check differences in lists (kindof)

``` python
def check_ingredient_match(recipe,ingredients)
	got_ingredients = 0
	miss_ingredients = []

	for i in range(len(recipe)):
		if recipe[i] != ingredients[i]:
			miss_ingredients.append(recipe[i])
		else:
			got_ingredients += 1
	percentage = float(got_ingredients/amt_ingredients*100)
	return percentage, miss_ingredients
```

Finish the `check_ingredient_match` function by looping over the `recipe` list. 
The function should calculate and return a `percentage` of ingredients the character has. 
As well as a list of missing ingredients from the recipe.

The placement of the ingredients matter! 
They must be in the same index as the recipe!

``` 
--------------------------------
Inputs:
recipe: ['Dragon Scale', 'Unicorn Hair', 'Phoenix Feather', 'Troll Tusk', 'Mandrake Root', 'Griffin Feather', 'Elf Dust', 'Goblin Ear']
gathered_ingredients: ['Dragon Scale', 'Goblin Ear', 'Phoenix Feather', 'Elf Dust', 'Mandrake Root', 'Griffin Feather', 'Elf Dust', 'Goblin Ear']
Expecting: (75.0, ['Unicorn Hair', 'Troll Tusk'])
Actual: (75.0, ['Unicorn Hair', 'Troll Tusk'])
Pass
---------------------------------
Inputs:
recipe: ['Dragon Scale', 'Unicorn Hair', 'Phoenix Feather', 'Troll Tusk', 'Mandrake Root', 'Griffin Feather', 'Elf Dust']
gathered_ingredients: ['Dragon Scale', 'Unicorn Hair', 'Phoenix Feather', 'Troll Tusk', 'Mandrake Root', 'Griffin Feather', 'Elf Dust']
Expecting: (100.0, [])
Actual: (100.0, [])
Pass
============= PASS ==============
2 passed, 0 failed

```

---
## 9.x Comparison of lists also

``` python
def validate_path(expected_path, character_path):
    character_name = character_path[0]
    correct_points = 0
    for i in range(len(expected_path)):
        if expected_path[i] == character_path[i+1]:
            correct_points += 1
    percentage = correct_points/len(expected_path)*100
    return character_name, percentage
```

Complete the `validate_path` function. 
It should compare thhe expected sequence of points with the actual sequence taken
by a character and calculate how accurate character followed intended path.

##### Inputs
- `expected_path` : a list of points that are correct path 
- `character_path` : list where first index is name of char, rest is points they visited.

##### Outputs
- `character_name`
- `percentage` : accuracy of the character w intended path.

```
---------------------------------
Inputs:
expected_path: ['A', 'B', 'C', 'D', 'E']
character_path: ['Dellbi', 'A', 'B', 'C', 'D', 'E']
Expecting: ('Dellbi', 100.0)
Actual: ('Dellbi', 100.0)
Pass
---------------------------------
Inputs:
expected_path: ['A', 'B', 'C', 'D', 'E']
character_path: ['Kaladin', 'A', 'X', 'C', 'D', 'E']
Expecting: ('Kaladin', 80.0)
Actual: ('Kaladin', 80.0)
Pass
============= PASS ==============
2 passed, 0 failed
```

---
## 9.x access each letter in each word

``` python
def double_string(string):
    doubled = []
    for character in string:
        doubled.append(character*2)
    doubled = "".join(doubled)
    return doubled
```

Complete the `double_string` function.
It takes string as input and returns a 'doubled' version, including spaces.

``` 
---------------------------------
Input: Hello there
Expecting: HHeelllloo  tthheerree
Actual: HHeelllloo  tthheerree
Pass
---------------------------------
Input: General Kenobi
Expecting: GGeenneerraall  KKeennoobbii
Actual: GGeenneerraall  KKeennoobbii
Pass
============= PASS ==============
2 passed, 0 failed
```

---
## 10.1 Creating a Dictionary
### From individual inputs to dictionary

``` python
def get_character_record(name, server, level, rank):
    char_dir = {
        "name": name,
        "server": server,
        "level": level,
        "rank": rank,
        "id": f'{name}#{server}'
    }
    return char_dir
```

Complete the `get_character_record` function. 
It takes a character's `name` `server` `level` and `rank` as individual inputs, and returns dict:
- `name`
- `server`
- `level`
- `rank` 
- `id` 

The `id` key maps to the `name` + `server` w/ `#` in the middle... (`name#server`)

```
---------------------------------
Test Case #1

Expected: name: bloodwarrior123
Actual:   name: bloodwarrior123

Expected: server: server1
Actual:   server: server1

Expected: level: 5
Actual:   level: 5

Expected: rank: 1
Actual:   rank: 1

Expected: id: bloodwarrior123#server1
Actual:   id: bloodwarrior123#server1

Pass
---------------------------------
Test Case #2

Expected: name: fronzenboi
Actual:   name: fronzenboi

Expected: server: server2
Actual:   server: server2

Expected: level: 2
Actual:   level: 2

Expected: rank: 1
Actual:   rank: 1

Expected: id: fronzenboi#server2
Actual:   id: fronzenboi#server2

Pass
============= PASS ==============
2 passed, 0 failed
```

---
## 10.3 Accessing Values in Dictionaries

``` python
car = {
    "make": "tesla",
    "model": "3"
}
print(car["make"])
```

```
tesla
```


### 10.3.1 Accessing Values or Keys in Dicts

``` python
ex_dict = {"a": "anteater", "b": "bumblebee", "c": "cheetah"}

ex_dict.keys()
# dict_keys(["a","b","c"])

ex_dict.values()
# dict_values(["anteater", "bumblebee", "cheetah"])

ex_dict.items()
# dict_items([("a","anteater"),("b","bumblebee"),("c","cheetah")])
```


---
## 10.4 Creating a Dict from string

``` python
names = ["jack bronson", "jill mcarty", "john denver"]
def make_dict(names):
	names_dict = {}
	for name in names:
	    # .split() returns each name as single words
	    name_list = name.split()

	    # here we update the dictionary
	    # dict[key] = value
	    names_dict[name_list[0]] = name_list[1]

	print(names_dict)
# Prints: {'jack': 'bronson', 'jill': 'mcarty', 'john': 'denver'}
```

```
key      value      key     value     key     value
{'jack': 'bronson', 'jill': 'mcarty', 'john': 'denver'}
```

---
## Updating a Value

``` python
full_names = ["jack bronson", "james mcarty", "jack denver"]
def make_dict(full_names):
	# create empty dictionary
	names_dict = {}
	for full_name in full_names:
	    # split full_names
	    names = full_name.split()
	    # assign first string to first_name
	    first_name = names[0]
	    # assign second string to last_name
	    last_name = names[1]
	    # assign dict[key] = value
	    names_dict[first_name] = last_name

	print(names_dict)
```

```
# key jack appears twice, so value is updated from bronson to denver
{
  'jack': 'denver',
  'james': 'mcarty'
}
```

---
## 10.6 To Delete a Value

``` python
names_dict = {
    "jack": "bronson",
    "jill": "mcarty",
    "joe": "denver"
}

del names_dict["joe"]

print(names_dict)
```

```
{'jack': 'bronson', 'jill': 'mcarty'}
```

---
## 10.x Checking for existence

``` python
cars = {
	"ford": 'f150',
	'tesla': '3'
}

print('ford' in cars)
# prints: True

print('gmc' in cars)
# prints: False
```

```

```

---
## 10.x counting enemies list -> enemy dict with count as values

``` python
def count_enemies(enemy_names):
	# creating new dictionary
    enemies_dict = {}
    # for every enemy in list:
    for enemy_name in enemy_names:
	    # if enemy already in dict, add 1 to count
        if enemy_name in enemies_dict:
            enemies_dict[enemy_name] += 1
        # if enemy not in dict, create a key/value pair with 1 as value
        else:
            enemies_dict[enemy_name] = 1
    return enemies_dict
```

```
---------------------------------
Inputs: ['jackal', 'kobold', 'soldier']
Expecting: {'jackal': 1, 'kobold': 1, 'soldier': 1}
Actual: {'jackal': 1, 'kobold': 1, 'soldier': 1}
Pass
---------------------------------
Inputs: ['jackal', 'kobold', 'jackal']
Expecting: {'jackal': 2, 'kobold': 1}
Actual: {'jackal': 2, 'kobold': 1}
Pass
============= PASS ==============
2 passed, 0 failed
```

---
## 10.7.1 naming variables inside Dict

``` python
fruit_sizes = {
    "apple": "small",
    "banana": "large",
    "grape": "tiny"
}
# we can use any word instead of 'name'
# we are also assigning keys as 'name'
for name in fruit_sizes:
	# assigning values as 'size'
    size = fruit_sizes[name]
    # using both variables assigned: 'name' + 'size'
    print(f"name: {name}, size: {size}")
    
# name: apple, size: small
# name: banana, size: large
# name: grape, size: tiny
```

### 10.7.2 Get the most common (highest value) in dict

``` python
def get_most_common_enemy(enemies_dict):
    most_common = [None, float("-inf")]
    
    for enemy in enemies_dict:
	    # values assigned as 'number'
        number = enemies_dict[enemy]
        if number > most_common[1]:
            most_common[0], most_common[1] = enemy, number
    
    return most_common[0]
```

We need to display on our player's screens what the most common enemy in a given area of the game map is.

Complete the `get_most_common_enemy` function by iterating over all enemies in the dictionary and returning only the name of the enemy with the highest count. If there are no enemies, return `None`.

enemies_dict is a dictionary of `name` -> `count`.

```
---------------------------------
Inputs: {'jackal': 4, 'kobold': 3, 'soldier': 10, 'gremlin': 5}
Expecting: soldier
Actual: soldier
Pass
---------------------------------
Inputs: {'jackal': 1, 'kobold': 3, 'soldier': 2, 'gremlin': 5}
Expecting: gremlin
Actual: gremlin
Pass
============= PASS ==============
2 passed, 0 failed
```

---
## 10.x Accessing nested dictionaries

``` python
{
    "entity": {
        "character": {
            "name": "Kaladin",
            "quests": {
                "bridge_run": {
                    "status": "In Progress",
                },
                "talk_to_syl": {
                    "status": "Completed",
                },
            },
        }
    }
}
```

``` python
# To get the 'status' of 'bridge_run':
return character['entity']['character']['quests']['talk_to_syl']['status']
```

---
## Merging Dictionaries + Assigning values from air

``` python
def merge(dict1, dict2):
	# Creating a new dictionary where merging gon happen
    merged_dict = {}
    
    for key in dict1:
	    # left side creates new key, right side assigns value from dict1[key]
	    # Assigns the 'value', not the key
        merged_dict[key] = dict1[key]
    
    for key in dict2:
        merged_dict[key] = dict2[key]
    
    return merged_dict

# magically takes merged_dict as score_dict ???
def total_score(score_dict):
    total = 0
    for key in score_dict:
        total += score_dict[key]
    return total

```

```
---------------------------------
Inputs:
 * first_half: {'first_quarter': 24, 'second_quarter': 31}
 * second_half: {'third_quarter': 29, 'fourth_quarter': 40}
Expecting: 124
Actual: 124
Pass
---------------------------------
Inputs:
 * first_half: {'first_quarter': 12, 'second_quarter': 2}
 * second_half: {'third_quarter': 32, 'fourth_quarter': 87}
Expecting: 133
Actual: 133
Pass
---------------------------------
Inputs:
 * first_half: {}
 * second_half: {}
Expecting: 0
Actual: 0
Pass
============= PASS ==============
3 passed, 0 failed
```

```
print(merged_dict)

{'first_quarter': 12, 'second_quarter': 2, 'third_quarter': 32, 'fourth_quarter': 87}
```

---
## 10.x create a receipt,  unfound items, and total price

``` python
def calculate_total(items_purchased, pinned_list):
    item_prices = {
        "health_potion": 10.00,
        "mana_potion": 12.00,
        "gold_dust": 5.00,
        "dwarven_ale": 8.00,
        "enchanted_scroll": 25.00,
        "ice_cold_milk": 50.00,
        "herbs": 7.00,
        "crystal_shard": 20.00,
        "magic_ring": 100.00,
        "mystic_amulet": 150.00,
    }

    # Don't touch above this line

    # unpurchased_items = items in pinned_list that aint 
    #     found in items_purchased
    unpurchased_items = []
    for item in pinned_list:
	    # for each item in pinned list, if item is not in items_purchased, add it to unpurchased_items list
        if item not in items_purchased:
            unpurchased_items.append(item)

    # receipt is a dict
    # containing all the items player purchased
    # keys are items names
    # values are prices from item_prices
    receipt = {}
    for item in items_purchased:
	    # add every purchased item to receipt dictionary with 'item_prices[item]' as the value
        receipt[item] = item_prices[item]

    total = 0
    # add all the values (receipt[item]) to the total
    for item in receipt:
        total += receipt[item]

    return unpurchased_items, receipt, total
```

```
---------------------------------
Inputs: 
(
	[
		'health_potion', 
		'mana_potion', 
		'gold_dust', 
		'herbs', 
		'crystal_shard', 
		'dwarven_ale'
	], 
	[
		'health_potion', 
		'mana_potion', 
		'ice_cold_milk', 
		'gold_dust', 
		'herbs', 
		'crystal_shard', 
		'magic_ring', 
		'dwarven_ale', 
		'mystic_amulet'
	]
)
Expecting: 
(
	[
		'ice_cold_milk', 
		'magic_ring', 
		'mystic_amulet'
	], 
	{
		'health_potion': 10.0, 
		'mana_potion': 12.0, 
		'gold_dust': 5.0, 
		'herbs': 7.0, 
		'crystal_shard': 20.0, 
		'dwarven_ale': 8.0
	}, 
		62.0
)
Actual: 
(
	[
		'ice_cold_milk', 
		'magic_ring', 
		'mystic_amulet'
	], 
	{
		'health_potion': 10.0, 
		'mana_potion': 12.0, 
		'gold_dust': 5.0, 
		'herbs': 7.0, 
		'crystal_shard': 20.0, 
		'dwarven_ale': 8.0
	}, 
		62.0
)
Pass
---------------------------------
Inputs: 
(
	[
		'health_potion', 
		'gold_dust', 
		'herbs', 
		'crystal_shard'
	], 
	[
		'health_potion', 
		'mana_potion', 
		'gold_dust', 
		'ice_cold_milk', 
		'herbs', 
		'magic_ring', 
		'crystal_shard', 
		'mystic_amulet'
	]
)
Expecting: 
(
	[
		'mana_potion', 
		'ice_cold_milk', 
		'magic_ring', 
		'mystic_amulet'
	], 
	{
		'health_potion': 10.0, 
		'gold_dust': 5.0, 
		'herbs': 7.0, 
		'crystal_shard': 20.0
	}, 
		42.0
)
Actual: 
(
	[
		'mana_potion', 
		'ice_cold_milk', 
		'magic_ring', 
		'mystic_amulet'
	], 
	{
		'health_potion': 10.0, 
		'gold_dust': 5.0, 
		'herbs': 7.0, 
		'crystal_shard': 20.0
	}, 
		42.0
)
Pass
---------------------------------
Inputs: 
(
	[
		'health_potion', 
		'mana_potion', 
		'gold_dust', 
		'ice_cold_milk', 
		'herbs', 
		'magic_ring', 
		'crystal_shard', 
		'mystic_amulet'
	], 
	[
		'health_potion', 
		'gold_dust', 
		'herbs', 
		'crystal_shard'
	]
)
Expecting: 
(
	[], 
	{
		'health_potion': 10.0, 
		'mana_potion': 12.0, 
		'gold_dust': 5.0, 
		'ice_cold_milk': 50.0, 
		'herbs': 7.0, 
		'magic_ring': 100.0, 
		'crystal_shard': 20.0, 
		'mystic_amulet': 150.0
	}, 
		354.0
)
Actual: 
(
	[], 
	{
		'health_potion': 10.0, 
		'mana_potion': 12.0, 
		'gold_dust': 5.0, 
		'ice_cold_milk': 50.0, 
		'herbs': 7.0, 
		'magic_ring': 100.0, 
		'crystal_shard': 20.0, 
		'mystic_amulet': 150.0
	}, 
		354.0
)
Pass
============= PASS ==============
3 passed, 0 failed
```

---
## 11.1 Removing Duplicates from a List

``` python
def remove_duplicates(spells):
	# use 'set()' to create a set
	# sets don't allow duplicates
	# '.add()' to add value to a set
	# No error will be raised if u add a duplicate, just no work
	# like dictionaries, they use '{}'
	# sets are unordered
    removed_set = set()
    removed_list = []
    for spell in spells:
        removed_set.add(spell)
    for spell in removed_set:
        removed_list.append(spell)
    return removed_list
```

### Important
A set can be used to remove duplicates from a list, 
You can accomplish this by :
1. creating set,
2. adding all items of list to it,
3. iterating over the set,
4. adding all items back into a list,
5. returning a list

```
---------------------------------
Inputs:
 * spells: ['fireball', 'eldritch blast', 'fireball', 'eldritch blast', 'chill touch', 'eldritch blast', 'chill touch', 'chill touch', 'fireball', 'fireball', 'shocking grasp', 'fireball', 'fireball']
Expecting: ['chill touch', 'eldritch blast', 'fireball', 'shocking grasp']
Actual: ['chill touch', 'eldritch blast', 'fireball', 'shocking grasp']
Pass
============= PASS ==============
1 passed, 0 failed
```

[[11.1_Sets]]

