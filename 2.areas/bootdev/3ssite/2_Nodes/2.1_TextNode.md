We're going to need a way to represent all the different types of inline text. 
We're going to be parsing Markdown text, and outputting it to HTML, 
so we need an intermediate representation of the text in our code. 

When I say 'inline' I just mean text that is part of a larger block of text. 
For us, this includes: 

- Normal text
- bold text
- italic text
- code text
- links
- images

Everything else we're considering block level, like headings, paragraphs, and bullet lists, and we'll handle those later. 

### Assignment
1. Create a simple `main.sh` shell script in the root of the project. 
- remember to make it executable `chmod +x main.sh`
- This will be a convenient way to run our code. It should contain: `python3 src/main.py`

2. Create a `src` directory with a `main.py` python file. This is where we'll write our Python code. Make it print "hello world", and make sure that running the `main.sh` script runs the` main.py` file and prints "hello world":
``` bash
./main.sh
# hello world
```
3. Create a .gitignore file in the root of the project. It should contain: `__pycache__/`
This will prevent autogenerated `__pycache__` directories form being committed to Git. 
Finally, create a `src/textnode.py` file.

4. In `textnode.py` create an `enum` called `TextType`. It should cover all the types of text nodes mentioned above. 
Example of creating an enum:
``` python
from enum import Enum

class Bender(Enum):
    AIR_BENDER = "air"
    WATER_BENDER = "water"
    EARTH_BENDER = "earth"
    FIRE_BENDER = "fire"
```

5. In `textnode.py` create a class called `TextNode`. It should have 3 properties that can be set in the constructor:
	- `self.text` - text content of the node
	- `self.text_type` - type of text this node contains. which is a member of the `TextType` enum.
	- `self.url` - The url of the link or image, if the text is a link. Default to None if nothing is passed in.

6. Create an `__eq__` method that returns `True` if all of the properties of two `TextNode` objects are equal. 
7. Create a `__repr__` method that returns a string representation of the `TextNode` object. It should look llike this: `TextNode(TEXT, TEXT_TYPE, URL)`
Note: you may wanna use `.value` on the `text_type` field to get the string representation of the enum . 

Where the TEXT, TEXT_TYPE, and URL are the values of the `text`, `text_type`, and `url` properties, respectively.

8. Create a `main()` function in `main.py` and call it. The function should create a new `TextNode` object with some dummy values. Print the object and make sure it looks like you'd expect. 
9. Run and submit.

##### `main.py`
``` python
# 2. 
# 
from textnode import TextNode, TextType

def main():
    node = TextNode('This is a text node', TextType.BOLD_TEXT, 'https://www.boot.dev')
    print(node)

if __name__ == '__main__':
    main()
```

##### `textnode.py`
``` python
# 4. create enum
from enum import Enum

class TextType(Enum):
    NORMAL = 'normal' 
    BOLD = 'bold'
    ITALIC = 'italic'
    CODE = 'code'
    LINK = 'link'
    IMAGE = 'image'

# 5. create class
class TextNode:
    def __init__(self, text, text_type, url=None):
        self.text = text
        self.text_type = text_type
        self.url = url

# 6. create eq method (equality)
# lets us compare two TextNode objects to see if they're the same. 
# without it python would compare object references instead of their contents.
    def __eq__(self, other):
        return self.text == other.text and self.text_type == other.text_type and self.url == other.url

# 7. create repr method
# provides a str representation of our object (helpful for debugging)
# Without it we would see som like this '<TextNode object at 0x235lk2jbk89384mn>'
# helps us see the important details at a glance.
    def __repr__(self):
        return f'TextNode({self.text}, {self.text_type.value}, {self.url})'
```

##### `main.sh`
``` shell
# 1. 
python3 src/main.py
```

##### `.gitignore`
```
# 3. ignores this directory from being commited.
__pycache__/
```

---
[[1.6_Architecture]]
[[2.2_TextNode-Tests]]